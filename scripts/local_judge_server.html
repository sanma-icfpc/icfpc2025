<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>ICFPC 2025 Local Judge Visualizer</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 0; display: flex; height: 100vh; }
    #left { width: 70%; border-right: 1px solid #ddd; display: flex; flex-direction: column; }
    #right { width: 30%; display: flex; flex-direction: column; }
    header { padding: 8px 12px; background:#f6f6f6; border-bottom:1px solid #ddd; }
    #viz { flex: 1; }
    #logs { flex: 1; padding: 8px; background: #0b1020; color: #bfe2ff; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; overflow: auto; }
    #events { flex: 1; overflow: auto; }
    .badge { display:inline-block; padding:2px 6px; border-radius: 10px; background:#eee; margin-left:6px; }
    .hex { fill: #8db3e2; stroke: #ffffff; stroke-width: 2px; opacity: 0.55; }
    .hex.current { fill: #e15759; opacity: 0.9; }
    .edge { stroke: #555; stroke-width: 2px; opacity: 0.95; fill: none; }
    .edge.self { stroke-dasharray: 5 4; }
    .edge.diff-missing { stroke: #d62728; stroke-width: 2.5px; }
    .edge.diff-extra { stroke: #2ca02c; stroke-width: 2.5px; }
    .doorlabel { font: 13px monospace; fill: #333; user-select: none; }
    .doorlabel.active { fill: #d62728; font-weight: 700; paint-order: stroke; stroke: #fff; stroke-width: 2px; }
    .edge.completed { stroke: #ff8c00; opacity: 0.45; }
    .edge.currentpath { stroke: #ff6a00; opacity: 0.95; stroke-width: 3.5px; }
    .edge.trail { stroke: #ff2f00; opacity: 1; stroke-width: 5px; stroke-linecap: round; }
    .edge.trailthin { stroke: #ff9a66; opacity: 0.9; stroke-width: 3px; stroke-linecap: round; }
    .roomlabel { font: 12px sans-serif; fill: #000; user-select: none; }
    .agent { fill: #ffcc00; stroke: #b8860b; stroke-width: 1.5px; }
    #playerControls { padding-right: 10px; }
    .pane-card { margin: 8px; }
    .list-group-item small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .list-group-item .title { font-weight: 600; }
    .list-group-item-action { cursor: pointer; }
    .tag-badge { min-width: 90px; display: inline-block; text-align: center; }
    .wrap { white-space: pre-wrap; word-break: break-word; }
  </style>
</head>
<body>
  <div id="left">
    <header class="d-flex align-items-center justify-content-between">
      <div>
        <span id="pname">(no selection)</span>
        <span class="badge bg-secondary" id="rooms"></span>
      </div>
      <div id="playerControls" class="d-flex align-items-center gap-2">
        <button id="btnPlayPause" class="btn btn-sm btn-primary" title="Play/Pause"><i id="icoPlayPause" class="bi bi-play-fill"></i></button>
        <button id="btnStepBack" class="btn btn-sm btn-outline-secondary" title="Step -0.5"><i class="bi bi-skip-start-fill"></i></button>
        <button id="btnStepFwd" class="btn btn-sm btn-outline-secondary" title="Step +0.5"><i class="bi bi-skip-end-fill"></i></button>
        <select id="selSpeed" class="form-select form-select-sm" style="width: 90px;">
          <option value="0.25">0.25×</option>
          <option value="0.5">0.5×</option>
          <option value="1" selected>1×</option>
          <option value="2">2×</option>
          <option value="4">4×</option>
        </select>
        <input id="rngStep" type="range" class="form-range" min="0" max="0" value="0" style="width: 220px;">
        <span id="lblStep" class="badge bg-info text-dark" style="min-width: 90px; text-align:center; font-family: ui-monospace, SFMono-Regular, Menlo, monospace;">0.0/0</span>
      </div>
    </header>
    <svg id="viz"></svg>
  </div>
  <div id="right" class="bg-light">
    <div id="sessions" class="pane-card card shadow-sm mb-2">
      <div class="card-header py-2 sticky-top bg-white"><strong>Sessions</strong><span class="text-muted ms-2 small">Click to switch</span></div>
      <div class="list-group list-group-flush" id="sessList"></div>
    </div>
    <div id="events" class="pane-card card shadow-sm mb-2">
      <div class="card-header py-2 sticky-top bg-white"><strong>Events</strong><span class="text-muted ms-2 small">Click to inspect</span></div>
      <div class="list-group list-group-flush" id="evList"></div>
    </div>
    <div class="pane-card card shadow-sm">
      <div class="card-header py-2 bg-white"><strong>Logs</strong></div>
      <pre id="logs" class="mb-0" style="max-height: 28vh;"></pre>
    </div>
  </div>
<script>
let state = null;
let events = [];
const svg = d3.select('#viz');
const logsEl = document.getElementById('logs');
const eventsEl = document.getElementById('events');
const sessionsEl = document.getElementById('sessions');
let currentSession = null;
// Playback controls and state
const btnPlayPause = document.getElementById('btnPlayPause');
const icoPlayPause = document.getElementById('icoPlayPause');
const btnStepBack = document.getElementById('btnStepBack');
const btnStepFwd = document.getElementById('btnStepFwd');
const selSpeed = document.getElementById('selSpeed');
const rngStep = document.getElementById('rngStep');
const lblStep = document.getElementById('lblStep');
let playback = { steps: [], half: 0, playing: false };
function appendLog(line){ logsEl.textContent += line + "\n"; logsEl.scrollTop = logsEl.scrollHeight; }
function layout(n){
  const w = document.getElementById('left').clientWidth; const h = document.getElementById('left').clientHeight - 50;
  svg.attr('width', w).attr('height', h);
  const R = Math.min(w,h)*0.38; const cx = w/2, cy = h/2;
  const pts = [];
  for(let i=0;i<n;i++){ const ang = (i/n)*2*Math.PI; pts.push({x: cx+R*Math.cos(ang), y: cy+R*Math.sin(ang)}); }
  return {w,h,pts};
}
function uniqueEdges(to){
  const S=new Set(); const E=[];
  for(let r=0;r<to.length;r++) for(let d=0;d<6;d++){
    const [r2,d2]=to[r][d]; const a=`${Math.min(r,r2)}-${Math.max(r,r2)}`; if(S.has(a)) continue; S.add(a); E.push([r,r2]);
  } return E;
}
function hexPoints(cx, cy, r){
  const pts=[]; for(let i=0;i<6;i++){ const ang = (Math.PI/3)*i - Math.PI/6; pts.push([cx + r*Math.cos(ang), cy + r*Math.sin(ang)]); } return pts;
}
function doorAnchorAt(L, r, d, R){ const pts=hexPoints(L.pts[r].x, L.pts[r].y, R); const a=pts[d], b=pts[(d+1)%6]; return {x:(a[0]+b[0])/2, y:(a[1]+b[1])/2}; }
function draw(){ if(!state||!state.active){ svg.selectAll('*').remove(); return; }
  const L = layout(state.numRooms); svg.selectAll('*').remove();
  const Rhex = Math.max(28, Math.min(56, Math.min(L.w, L.h) / 12));
  // Build per-door edges from (room,door)->(room,door) without collapsing multiples
  const edges = [];
  for(let r=0;r<state.to.length;r++){
    for(let d=0; d<6; d++){
      const [r2,d2] = state.to[r][d];
      const a = `${Math.min(r,r2)}-${Math.min(d,d2)}-${Math.max(r,r2)}-${Math.max(d,d2)}`;
      // include each undirected port-pair only once
      if(r < r2 || (r===r2 && d <= d2)) edges.push({r1:r,d1:d,r2:r2,d2:d2});
    }
  }
  function edgePath(e){
    const a = doorAnchorAt(L,e.r1,e.d1,Rhex);
    const b = doorAnchorAt(L,e.r2,e.d2,Rhex);
    if(e.r1===e.r2 && e.d1===e.d2){
      const cx = a.x, cy = a.y; const R = Rhex*0.35; const x0 = cx + R, y0 = cy;
      return {d:`M ${x0} ${y0} a ${R} ${R} 0 1 0 ${-2*R} 0 a ${R} ${R} 0 1 0 ${2*R} 0`, self:true};
    }
    function ctrl(r,d,anch){
      const pts = hexPoints(L.pts[r].x, L.pts[r].y, Rhex);
      const v = [pts[(d+1)%6][0]-pts[d][0], pts[(d+1)%6][1]-pts[d][1]]; // tangent
      let n = [v[1], -v[0]]; // normal
      const clen = Math.hypot(n[0], n[1]) || 1; n = [n[0]/clen, n[1]/clen];
      const toCenter = [anch.x - L.pts[r].x, anch.y - L.pts[r].y];
      if(n[0]*toCenter[0] + n[1]*toCenter[1] < 0){ n = [-n[0], -n[1]]; }
      const off = Rhex*0.7;
      return {x: anch.x + n[0]*off, y: anch.y + n[1]*off};
    }
    const c1 = ctrl(e.r1, e.d1, a);
    const c2 = ctrl(e.r2, e.d2, b);
    return {d:`M ${a.x} ${a.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${b.x} ${b.y}`, self:false};
  }
  svg.selectAll('path.edge').data(edges).enter().append('path')
    .attr('class',e=> (e.r1===e.r2 && e.d1===e.d2) ? 'edge self' : 'edge')
    .attr('d', e=>edgePath(e).d);
  // Rooms as hexagons with door numbers 0..5 on edges
  const rooms = svg.selectAll('g.room').data(L.pts.map((p,i)=>({i,...p})) ).enter().append('g').attr('class','room');
  rooms.append('polygon').attr('class','hex')
    .attr('points', d=> hexPoints(d.x,d.y,Rhex).map(p=>p.join(',')).join(' '));
  // Door labels 0..5 around edges
  rooms.each(function(d){ const g=d3.select(this); const pts = hexPoints(d.x,d.y,Rhex+6);
    for(let k=0;k<6;k++){ const a=pts[k], b=pts[(k+1)%6]; const mx=(a[0]+b[0])/2, my=(a[1]+b[1])/2;
      g.append('text').attr('class','doorlabel').attr('data-room', d.i).attr('data-door', k).attr('x',mx).attr('y',my).attr('text-anchor','middle').attr('dy','0.35em').text(String(k)); }
  });
  // Index and label text inside the hex for clarity
  rooms.append('text').attr('class','roomlabel')
    .attr('x',d=>d.x).attr('y',d=>d.y-2)
    .attr('text-anchor','middle')
    .style('font-weight','700')
    .style('paint-order','stroke')
    .style('stroke','#fff').style('stroke-width','2px')
    .text(d=>`#${d.i}`);
  rooms.append('text').attr('class','roomlabel')
    .attr('x',d=>d.x).attr('y',d=>d.y+12)
    .attr('text-anchor','middle')
    .style('paint-order','stroke')
    .style('stroke','#fff').style('stroke-width','2px')
    .text(d=>`[${(state.rooms[d.i] & 3).toString(2).padStart(2,'0')}]`);
}
function refresh(){
  fetch('/state').then(r=>r.json()).then(s=>{ state=s; if(!currentSession){ document.getElementById('pname').textContent = s.active? s.problemName : '(no selection)'; document.getElementById('rooms').textContent = s.active? `${s.numRooms} rooms` : ''; } draw(); });
  fetch('/events').then(r=>r.json()).then(e=>{ events=e.events||[]; (e.logs||[]).forEach(appendLog); renderEvents(); });
  fetch('/sessions').then(r=>r.json()).then(ss=>{ renderSessions(ss.sessions||[]); });
}
function renderSessions(list){ const ul=document.getElementById('sessList'); ul.innerHTML=''; list.forEach(s=>{
  const a=document.createElement('a'); a.href='#'; a.className='list-group-item list-group-item-action d-flex justify-content-between align-items-center';
  const left=document.createElement('div'); left.innerHTML = `<span class="title">#${s.id} ${s.problemName}</span> <small class="text-muted">(${s.rooms} rooms)</small><br><small class="text-muted">seed=<span class="mono">${s.seed}</span></small>`;
  const right=document.createElement('div'); right.innerHTML = `<span class="badge rounded-pill bg-primary me-1" title="explores">${s.explores}</span><span class="badge rounded-pill bg-success" title="guesses">${s.guesses}</span>`;
  a.appendChild(left); a.appendChild(right);
  if (currentSession===s.id) a.classList.add('active');
  a.onclick=(e)=>{ e.preventDefault(); stopPlayback(true); loadSession(s.id); };
  ul.appendChild(a);
}); }
function loadSession(id){ fetch(`/session?id=${id}`).then(r=>r.json()).then(s=>{
  if(s.error) return;
  currentSession = s.id;
  state = { active:true, problemName:s.problemName, rooms:s.labyrinth.labels, start:s.labyrinth.start, to:s.labyrinth.to, numRooms:s.rooms };
  document.getElementById('pname').textContent = s.problemName+` (#${s.id})`;
  document.getElementById('rooms').textContent = `${s.rooms} rooms`;
  draw();
  // Build synthetic events list from this session
  const evs=[]; s.explores.forEach(x=>evs.push({type:'explore', ...x})); s.guesses.forEach(x=>evs.push({type:'guess', ...x}));
  events = evs; renderEvents();
  // Reset playback UI
  playback.steps = []; playback.index = 0; playback.playing = false; if(playback.timer){ clearInterval(playback.timer); playback.timer=null; }
  rngStep.min = 0; rngStep.max = 0; rngStep.value = 0; lblStep.textContent = '0/0'; btnPlayPause.textContent = 'Play';
}); }
function renderEvents(){ const ul = document.getElementById('evList'); ul.innerHTML='';
  events.forEach((ev,idx)=>{
    const a = document.createElement('a'); a.href='#'; a.className='list-group-item list-group-item-action d-flex justify-content-between align-items-center';
    const left = document.createElement('div');
    if(ev.type==='explore'){
      const plansCount = ev.plans?.length || 0;
      const plansStr = JSON.stringify(ev.plans);
      const resultsStr = JSON.stringify(ev.results);
      left.innerHTML = `<span class=\"badge bg-primary me-2 tag-badge\">EXPLORE</span><span class=\"title\">${plansCount} plan(s)</span><br>`+
        `<div class=\"mono small wrap\">plans=${plansStr}\nresults=${resultsStr}\nqueryCount=${ev.queryCount}</div>`;
      a.onclick = (e)=>{ e.preventDefault(); stopPlayback(true); selectExplore(ev); startPlaybackOnce(); };
    } else if(ev.type==='guess'){
      const diffStr = ev.diff ? JSON.stringify(ev.diff) : '';
      left.innerHTML = `<span class=\"badge ${ev.correct?'bg-success':'bg-danger'} me-2 tag-badge\">GUESS</span><span class=\"title\">${ev.correct?'Correct':'Wrong'}</span>`+
        (diffStr? `<div class=\"mono small wrap mt-1\">diff=${diffStr}</div>` : '');
      a.onclick = (e)=>{ e.preventDefault(); stopPlayback(true); showGuessDiff(ev); };
    } else if(ev.type==='select'){
      left.innerHTML = `<span class=\"badge bg-secondary me-2 tag-badge\">SELECT</span><span class=\"title\">${ev.problemName}</span> <small class=\"text-muted\">rooms=${ev.rooms} seed=<span class=\"mono\">${ev.seed}</span> (${ev.mode})</small>`;
      a.classList.add('disabled');
    }
    const right = document.createElement('div'); right.innerHTML = '';
    a.appendChild(left); a.appendChild(right);
    ul.appendChild(a);
  });
}
function stepLabel(half, total){ const cur=(half/2).toFixed(1); return `${cur}/${total}`; }
function drawPlaybackAt(half){ if(!state||!state.active) return; const L = layout(state.numRooms); draw();
  const Rhex = Math.max(28, Math.min(56, Math.min(L.w, L.h) / 12));
  function pathFor(e){
    const a = doorAnchorAt(L,e.r1,e.d1,Rhex); const b = doorAnchorAt(L,e.r2,e.d2,Rhex);
    function ctrl(r,d,anch){ const pts=hexPoints(L.pts[r].x, L.pts[r].y, Rhex); const v=[pts[(d+1)%6][0]-pts[d][0], pts[(d+1)%6][1]-pts[d][1]]; let n=[v[1],-v[0]]; const clen=Math.hypot(n[0],n[1])||1; n=[n[0]/clen,n[1]/clen]; const toC=[anch.x-L.pts[r].x, anch.y-L.pts[r].y]; if(n[0]*toC[0]+n[1]*toC[1]<0){ n=[-n[0],-n[1]]; } const off=Rhex*0.7; return {x:anch.x+n[0]*off, y:anch.y+n[1]*off}; }
    if(e.r1===e.r2 && e.d1===e.d2){ const cx=a.x, cy=a.y; const R=Rhex*0.35; const x0=cx+R, y0=cy; return `M ${x0} ${y0} a ${R} ${R} 0 1 0 ${-2*R} 0 a ${R} ${R} 0 1 0 ${2*R} 0`; }
    const c1=ctrl(e.r1,e.d1,a), c2=ctrl(e.r2,e.d2,b); return `M ${a.x} ${a.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${b.x} ${b.y}`;
  }
  const full = Math.floor(half/2);
  for(let i=0;i<full;i++){
    const e = playback.steps[i];
    svg.append('path').attr('class','edge completed').attr('d', pathFor(e));
  }
  let cur = state.start; for(let i=0;i<full;i++) cur = playback.steps[i].r2;
  let agentX = L.pts[cur].x, agentY = L.pts[cur].y;
  // door highlights
  document.querySelectorAll('.doorlabel.active').forEach(el=>el.classList.remove('active'));
  if(half%2===1 && full < playback.steps.length){
    const e = playback.steps[full];
    const curveNode = svg.append('path').attr('d', curvePathForMove(L,Rhex,cur,e)).node();
    const total = curveNode.getTotalLength();
    const pt = curveNode.getPointAtLength(total*0.5);
    // strong trail to midpoint (polyline)
    const segs = 24; let poly = `M `; for(let j=0;j<=segs;j++){ const a = (j/segs)*(total*0.5); const p = curveNode.getPointAtLength(a); poly += `${p.x} ${p.y} ${j===segs?'':'L '}`; }
    svg.append('path').attr('class','edge trail').attr('d', poly);
    d3.select(curveNode).remove();
    agentX = pt.x; agentY = pt.y;
    const selA=document.querySelector(`.doorlabel[data-room="${cur}"][data-door="${e.d1}"]`);
    const selB=document.querySelector(`.doorlabel[data-room="${e.r2}"][data-door="${e.d2}"]`);
    if(selA) selA.classList.add('active'); if(selB) selB.classList.add('active');
  }
  svg.append('circle').attr('class','agent').attr('r',6).attr('cx',agentX).attr('cy',agentY);
  svg.selectAll('.hex').classed('current', false);
  d3.select(svg.selectAll('g.room').nodes()[cur]).select('polygon').classed('current', true);
  lblStep.textContent = stepLabel(half, playback.steps.length); rngStep.value = String(half);
}
function selectExplore(ev){ if(!state||!state.active) return; const steps=[]; let cur=state.start; ev.plans.forEach(plan=>{ for(let i=0;i<plan.length;i++){ const d=plan.charCodeAt(i)-48; const [nr, nd]=state.to[cur][d]; steps.push({r1:cur,d1:d,r2:nr,d2:nd}); cur=nr; }}); playback.steps=steps; playback.half=0; playback.playing=false; rngStep.min=0; rngStep.max=steps.length*2; rngStep.value=0; lblStep.textContent=stepLabel(0, steps.length); drawPlaybackAt(0); }
function showGuessDiff(ev){ if(!state||!state.active) return; const L = layout(state.numRooms); draw();
  const missing = ev.diff && ev.diff.missingEdges || [];
  const extra = ev.diff && ev.diff.extraEdges || [];
  const Rhex = Math.max(28, Math.min(56, Math.min(L.w, L.h) / 12));
  function edgePathDiff(pair){ const e={r1:pair[0][0],d1:pair[0][1],r2:pair[1][0],d2:pair[1][1]};
    // Mirror edgePath from draw()
    const a = doorAnchorAt(L,e.r1,e.d1,Rhex); const b = doorAnchorAt(L,e.r2,e.d2,Rhex);
    if(e.r1===e.r2 && e.d1===e.d2){ const cx=a.x, cy=a.y; const R=Rhex*0.35; const x0=cx+R, y0=cy; return `M ${x0} ${y0} a ${R} ${R} 0 1 0 ${-2*R} 0 a ${R} ${R} 0 1 0 ${2*R} 0`; }
    function ctrl(r,d,anch){ const pts=hexPoints(L.pts[r].x, L.pts[r].y, Rhex); const v=[pts[(d+1)%6][0]-pts[d][0], pts[(d+1)%6][1]-pts[d][1]]; let n=[v[1],-v[0]]; const clen=Math.hypot(n[0],n[1])||1; n=[n[0]/clen,n[1]/clen]; const toCenter=[anch.x-L.pts[r].x, anch.y-L.pts[r].y]; if(n[0]*toCenter[0]+n[1]*toCenter[1]<0){ n=[-n[0],-n[1]]; } const off=Rhex*0.7; return {x:anch.x+n[0]*off, y:anch.y+n[1]*off}; }
    const c1=ctrl(e.r1,e.d1,a), c2=ctrl(e.r2,e.d2,b); return `M ${a.x} ${a.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${b.x} ${b.y}`;
  }
  missing.forEach(p=>{ svg.append('path').attr('class','edge diff-missing').attr('d',edgePathDiff(p)); });
  extra.forEach(p=>{ svg.append('path').attr('class','edge diff-extra').attr('d',edgePathDiff(p)); });
}
refresh();
const es = new EventSource('/stream');
es.addEventListener('log', ev=>{ const d=JSON.parse(ev.data); appendLog(d.line); });
es.addEventListener('event', ev=>{ const d=JSON.parse(ev.data); events.push(d); renderEvents(); if(d.type==='select'){ currentSession=null; refresh(); }});
// Smooth animation-based playback
let playAgentSel = null;
function fullPathForMove(L, Rhex, curRoom, move){
  const srcDoor = doorAnchorAt(L, curRoom, move.d1, Rhex);
  const dstDoor = doorAnchorAt(L, move.r2, move.d2, Rhex);
  const startC = {x: L.pts[curRoom].x, y: L.pts[curRoom].y};
  const endC = {x: L.pts[move.r2].x, y: L.pts[move.r2].y};
  function ctrl(r,d,anch){ const pts=hexPoints(L.pts[r].x, L.pts[r].y, Rhex); const v=[pts[(d+1)%6][0]-pts[d][0], pts[(d+1)%6][1]-pts[d][1]]; let n=[v[1],-v[0]]; const clen=Math.hypot(n[0],n[1])||1; n=[n[0]/clen,n[1]/clen]; const toC=[anch.x-L.pts[r].x, anch.y-L.pts[r].y]; if(n[0]*toC[0]+n[1]*toC[1]<0) n=[-n[0],-n[1]]; const off=Rhex*0.7; return {x:anch.x+n[0]*off, y:anch.y+n[1]*off}; }
  const pre = `M ${startC.x} ${startC.y} L ${srcDoor.x} ${srcDoor.y}`;
  let mid;
  if(curRoom===move.r2 && move.d1===move.d2){ const cx=srcDoor.x, cy=srcDoor.y; const R=Rhex*0.35; const x0=cx+R, y0=cy; mid = ` M ${x0} ${y0} a ${R} ${R} 0 1 0 ${-2*R} 0 a ${R} ${R} 0 1 0 ${2*R} 0`; }
  else { const c1=ctrl(curRoom, move.d1, srcDoor); const c2=ctrl(move.r2, move.d2, dstDoor); mid = ` M ${srcDoor.x} ${srcDoor.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${dstDoor.x} ${dstDoor.y}`; }
  const post = ` L ${endC.x} ${endC.y}`;
  return pre + mid + post;
}
function curvePathForMove(L, Rhex, curRoom, move){
  const srcDoor = doorAnchorAt(L, curRoom, move.d1, Rhex);
  const dstDoor = doorAnchorAt(L, move.r2, move.d2, Rhex);
  function ctrl(r,d,anch){ const pts=hexPoints(L.pts[r].x, L.pts[r].y, Rhex); const v=[pts[(d+1)%6][0]-pts[d][0], pts[(d+1)%6][1]-pts[d][1]]; let n=[v[1],-v[0]]; const clen=Math.hypot(n[0],n[1])||1; n=[n[0]/clen,n[1]/clen]; const toC=[anch.x-L.pts[r].x, anch.y-L.pts[r].y]; if(n[0]*toC[0]+n[1]*toC[1]<0) n=[-n[0],-n[1]]; const off=Rhex*0.7; return {x:anch.x+n[0]*off, y:anch.y+n[1]*off}; }
  if(curRoom===move.r2 && move.d1===move.d2){ const cx=srcDoor.x, cy=srcDoor.y; const R=Rhex*0.35; const x0=cx+R, y0=cy; return `M ${x0} ${y0} a ${R} ${R} 0 1 0 ${-2*R} 0 a ${R} ${R} 0 1 0 ${2*R} 0`; }
  const c1=ctrl(curRoom, move.d1, srcDoor); const c2=ctrl(move.r2, move.d2, dstDoor);
  return `M ${srcDoor.x} ${srcDoor.y} C ${c1.x} ${c1.y}, ${c2.x} ${c2.y}, ${dstDoor.x} ${dstDoor.y}`;
}
function polylineFromCurve(node, startLen, len){
  const segs = 24; let d = 'M ';
  for(let j=0;j<=segs;j++){
    const a = startLen + (j/segs)*len; const p = node.getPointAtLength(a);
    d += `${p.x} ${p.y}${j===segs?'':' L '}`;
  }
  return d;
}
function animateFromHalf(startHalf){ if(!state||!state.active) return; const L = layout(state.numRooms); draw(); const Rhex = Math.max(28, Math.min(56, Math.min(L.w, L.h) / 12));
  const full = Math.floor(startHalf/2); const part = startHalf%2; // 0: center->mid, 1: mid->center
  for(let i=0;i<full;i++){ const e=playback.steps[i]; const d=fullPathForMove(L,Rhex,(i===0?state.start:playback.steps[i-1].r2), e); svg.append('path').attr('class','edge completed').attr('d', d); }
  let cur = state.start; for(let i=0;i<full;i++) cur = playback.steps[i].r2; playAgentSel = svg.append('circle').attr('class','agent').attr('r',6).attr('cx',L.pts[cur].x).attr('cy',L.pts[cur].y);
  svg.selectAll('.hex').classed('current', false); d3.select(svg.selectAll('g.room').nodes()[cur]).select('polygon').classed('current', true);
  playback.playing = true; btnPlayPause.textContent = 'Pause';
  animateStepHalf(L, Rhex, full, part, cur);
}
function animateStepHalf(L, Rhex, i, part, curRoom){ if(!playback.playing){ return; } if(i >= playback.steps.length){ playback.playing=false; btnPlayPause.textContent='Play'; playback.half=i*2; rngStep.value=String(playback.half); lblStep.textContent=stepLabel(playback.half, playback.steps.length); return; }
  const move = playback.steps[i];
  const dFull = fullPathForMove(L, Rhex, curRoom, move);
  const dCurve = curvePathForMove(L, Rhex, curRoom, move);
  const path = svg.append('path').attr('class','edge playpath currentpath').attr('d', dFull);
  const curveNode = svg.append('path').attr('class','edge').attr('d', dCurve).node();
  const trailThick = svg.append('path').attr('class','edge trail');
  const trailThin  = svg.append('path').attr('class','edge trailthin');
  // highlight active doors
  document.querySelectorAll('.doorlabel.active').forEach(el=>el.classList.remove('active'));
  const selA = document.querySelector(`.doorlabel[data-room="${curRoom}"][data-door="${move.d1}"]`);
  const selB = document.querySelector(`.doorlabel[data-room="${move.r2}"][data-door="${move.d2}"]`);
  if(selA) selA.classList.add('active'); if(selB) selB.classList.add('active');
  const total = path.node().getTotalLength(); const totalCurve = curveNode.getTotalLength(); const base=900; const factor = 1/parseFloat(selSpeed.value||'1');
  if(part===0){ // center -> mid
    // 1) center -> source door (linear)
    const srcDoor = doorAnchorAt(L, curRoom, move.d1, Rhex);
    playAgentSel.transition().duration(base*factor*0.2).ease(d3.easeLinear).tween('toSrcDoor', function(){
      const x0 = L.pts[curRoom].x, y0 = L.pts[curRoom].y; const x1 = srcDoor.x, y1 = srcDoor.y;
      return function(t){ playAgentSel.attr('cx', x0 + (x1-x0)*t).attr('cy', y0 + (y1-y0)*t); };
    }).on('end', ()=>{
      // 2) along curve: src door -> midpoint
      playAgentSel.transition().duration(base*factor*0.3).ease(d3.easeLinear).tween('doorToMid', function(){
        return function(t){
          const curLen = t*(totalCurve*0.5);
          const dThick = polylineFromCurve(curveNode, 0, curLen);
          const dThin  = polylineFromCurve(curveNode, curLen, totalCurve*0.5 - curLen);
          trailThick.attr('d', dThick);
          trailThin.attr('d', dThin);
          const pm = curveNode.getPointAtLength(curLen);
          playAgentSel.attr('cx', pm.x).attr('cy', pm.y);
        };
      }).on('end', ()=>{
        playback.half = i*2 + 1; rngStep.value=String(playback.half); lblStep.textContent=stepLabel(playback.half, playback.steps.length);
        // 3) midpoint -> dest door along curve
        playAgentSel.transition().duration(base*factor*0.2).ease(d3.easeLinear).tween('midToDestDoor', function(){
          return function(t){
            const curLen = totalCurve*0.5 + t*(totalCurve*0.5);
            const dThick = polylineFromCurve(curveNode, 0, curLen);
            const dThin  = polylineFromCurve(curveNode, curLen, totalCurve - curLen);
            trailThick.attr('d', dThick);
            trailThin.attr('d', dThin);
            const pm = curveNode.getPointAtLength(curLen);
            playAgentSel.attr('cx', pm.x).attr('cy', pm.y);
          };
        }).on('end', ()=>{
          // 4) dest door -> center (linear)
          const dstDoor = doorAnchorAt(L, move.r2, move.d2, Rhex);
          playAgentSel.transition().duration(base*factor*0.1).ease(d3.easeLinear).tween('destDoorToCenter', function(){
            const x0 = dstDoor.x, y0 = dstDoor.y; const x1 = L.pts[move.r2].x, y1 = L.pts[move.r2].y;
            return function(t){ playAgentSel.attr('cx', x0 + (x1-x0)*t).attr('cy', y0 + (y1-y0)*t); };
          }).on('end', ()=>{
            path.remove(); d3.select(curveNode).remove(); trailThick.remove(); trailThin.remove();
            const nextRoom = move.r2; playback.half = i*2 + 2; rngStep.value=String(playback.half); lblStep.textContent=stepLabel(playback.half, playback.steps.length);
            svg.selectAll('.hex').classed('current', false); d3.select(svg.selectAll('g.room').nodes()[nextRoom]).select('polygon').classed('current', true);
            animateStepHalf(L, Rhex, i+1, 0, nextRoom);
          });
        });
      });
    });
  } else { // mid -> center
    // jump agent to mid immediately
    const ptHalf = path.node().getPointAtLength(total*0.5); playAgentSel.attr('cx', ptHalf.x).attr('cy', ptHalf.y);
    // from mid to door (thin grows ahead), thick from src->mid
    const d1 = polylineFromCurve(curveNode, 0, totalCurve*0.5); trailThick.attr('d', d1);
    playAgentSel.transition().duration(base*factor*0.2).ease(d3.easeLinear).tween('midToDoor', function(){ return function(t){ const d2 = polylineFromCurve(curveNode, totalCurve*0.5, t*totalCurve*0.5); trailThin.attr('d', d2); const pm = curveNode.getPointAtLength(totalCurve*0.5 + t*totalCurve*0.5); playAgentSel.attr('cx', pm.x).attr('cy', pm.y); };}).on('end', ()=>{
      // door to center
      playAgentSel.transition().duration(base*factor*0.1).ease(d3.easeLinear).tween('doorToCenter', function(){ return function(t){ const pos = total*0.9 + t*(total*0.1); const pt = path.node().getPointAtLength(pos); playAgentSel.attr('cx', pt.x).attr('cy', pt.y); };}).on('end', ()=>{
        path.remove(); d3.select(curveNode).remove(); trailThick.remove(); trailThin.remove(); const nextRoom = move.r2; playback.half = i*2 + 2; rngStep.value=String(playback.half); lblStep.textContent=stepLabel(playback.half, playback.steps.length); svg.selectAll('.hex').classed('current', false); d3.select(svg.selectAll('g.room').nodes()[nextRoom]).select('polygon').classed('current', true); animateStepHalf(L, Rhex, i+1, 0, nextRoom);
      });
    });
  }
}
function startPlaybackOnce(){ if(playback.steps.length===0) return; if(playback.half>=playback.steps.length*2) playback.half=0; icoPlayPause.classList.remove('bi-play-fill'); icoPlayPause.classList.add('bi-pause-fill'); animateFromHalf(playback.half); }
btnPlayPause.onclick = ()=>{ if(!state||!state.active) return; if(playback.steps.length===0) return; if(playback.playing){ stopPlayback(false); } else { if(playback.half>=playback.steps.length*2) playback.half=0; startPlaybackOnce(); } };
selSpeed.onchange = ()=>{ if(playback.playing){ btnPlayPause.onclick(); btnPlayPause.onclick(); } };
rngStep.oninput = ()=>{ const half = parseInt(rngStep.value||'0',10); playback.half = half; stopPlayback(false); drawPlaybackAt(half); };
btnStepBack.onclick = ()=>{ if(!state||!state.active) return; if(playback.steps.length===0) return; stopPlayback(false); playback.half = Math.max(0, playback.half - 1); rngStep.value=String(playback.half); drawPlaybackAt(playback.half); };
btnStepFwd.onclick = ()=>{ if(!state||!state.active) return; if(playback.steps.length===0) return; stopPlayback(false); playback.half = Math.min(playback.steps.length*2, playback.half + 1); rngStep.value=String(playback.half); drawPlaybackAt(playback.half); };
function stopPlayback(resetHalf=false){
  if(playback.playing){ playback.playing=false; }
  d3.selectAll('.playpath').remove();
  d3.selectAll('.playtrail').remove();
  if (typeof playAgentSel !== 'undefined' && playAgentSel) {
    try { playAgentSel.interrupt(); } catch {}
  }
  icoPlayPause.classList.remove('bi-pause-fill');
  icoPlayPause.classList.add('bi-play-fill');
  if(resetHalf){ playback.half=0; rngStep.value='0'; lblStep.textContent=stepLabel(0, playback.steps.length||0); }
}
</script>
</body></html>
