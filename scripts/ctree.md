# ICFPC 2025: Classification Tree（DT）+ マーキング 解法設計書

> 目的：**最小の探索呼び出し回数で正しい地図を確定**するために、Classification Tree（Discrimination Tree; DT）を中核とし、Addendum の **マーキング（`[k]`）**を“実験語”に統合した厳密解法を設計する。  
> 本書は「問題の理解・整理」を最重視し、段階導入できる TODO を付す。

---

## 1. 問題の正確なモデル化（合意事項）

- **迷宮モデル**  
  無向 6-正則グラフ（各部屋にポート 0..5）。多重辺・自己ループあり。  
  すべての遷移は決定的・双方向（どこかのポートで必ず戻れる）。

- **観測とプロトコル**  
  ルート・プラン（扉列、Addendum 後は `[k]` を含め可）を `/explore` で実行し、各ステップで**可視な 2-bit ラベル**を取得する。  
  長さ `x` のプランに対し、**開始室を含めた `x+1` 個**のラベル列を返す（以降これを「観測列」）。  
  `/explore` 呼び出しには +1 ペナルティが付くため、**バッチ送信**が有利。

- **Addendum での拡張（重要）**  
  プラン中に **`[k]`（k∈{0,1,2,3}）で現室のラベルを書き換え**可。プラン終了時に原状復帰。  
  **ルート長の制約**：**ドア歩数**（扉移動のみカウント）≤ `6n`。`[k]` はドア歩数に**含めない**（本文の語り口に従う自然解釈）。  
  同値性は **マーキングを含むプラン**に対する不可分性で定義される。

- **抽象化**  
  入力アルファベット：  
  - Lightning：`Σ = {0,1,2,3,4,5}`  
  - Addendum：`Σ′ = Σ ∪ {[0],[1],[2],[3]}`  
  迷宮は **Moore 機械**（状態=部屋、遷移=扉、出力=2-bit ラベル）として扱う。  
  DT は**“アクセス語 × 実験語”**で観測ベクトルを作り、状態を識別する。

---

## 2. 解法の全体像

1) **DT による学習**  
- `S`：開始からの**アクセス語**集合（BFSで増やす）。  
- `E`：**実験語**集合（短い「区別接尾語」）。  
- 各アクセス語 `s` と各実験語 `e` に対し、`Out(s,e)` を観測し、**分類木**の葉（=型 type）に振り分ける。  
- **閉包/整合性**（DTの定則）を満たすまで `E` を追加し、最小の仮説機（Σ′意味論）を得る。

2) **マーキングの統合**  
- Addendum では `E` に `[k]` を含む実験語を**系統的に導入**し、**クローン（コピー）**を**DTだけで分割**する。  
- これにより、**ペアテストやバックトラックを使わず**に、Σ′-最小機械が直接得られる。

3) **提出用の無向ペアリング（扉↔扉）**  
- 学んだ遷移関数 `δ` から、各 `(room, door)` の**相手側 `(room', door')`**を **表引きのみ**で決定する（新規探索は不要）。  
- 多重辺・自己ループは 1:1 対応で貪欲に割り当て、**相互参照が合致**することを検査。

---

## 3. Discrimination Tree（DT）の構成要素

- **アクセス語 `S`**  
  `ε`（開始）から BFS。各 `s∈S` は到達状態の**代表**。`sa`（a∈Σ）で遷移の被覆を広げる。  
  ※実移動を伴うのは Σ だけ。`[k]` は**実験語にのみ**現れる。

- **実験語 `E`**  
  短い**接尾語**。`e` を “`[k]` と Σ の短い列” のテンプレから生成。  
  DT の矛盾に出会うたびに**最短**の反例接尾語を追加（次節テンプレ参照）。

- **分類木（Discrimination Tree）**  
  ルート：`E` の最初の実験語  
  内部ノード：`Out(s,e)` の結果で枝分かれ  
  葉：**type**（現時点で識別可能な挙動型）  
  収束：**閉包**（全 `sa` がどこかの葉に入る）と**整合性**（同葉の `sa` 遷移先型が一致）が成立

---

## 4. マーキング実験語の設計（Σ′）

**狙い**：同じ Σ-挙動を示すクローン同士を、**短い `[k]` 付き接尾語**で分割する。  
**方針**：以下のテンプレを **長さ優先**で `E` に供給。必要最小限で収束。

### 4.1 テンプレ群（短い順）

- **LC（Loop-Color）**：`[1] a`  
  - 同一点に戻る場合、`a` 後のラベルに `[1]` の痕跡が出るかで識別。  
  - 目的：自己ループや「極近」な混同の早期解消。

- **MR（Mark-and-Return）**：`[1] a b`  
  - `a` で一歩進み、`b` で戻る（`b` は戻り候補のうち短いもの）。戻れた場合のみ `[1]` が効く。  
  - 目的：**戻り方向が複数ある型**の切り分け。

- **2HR（Two-Hop Reflection）**：`[2] a c`  
  - 2-hop の反射（`a` に続いて `c`）。周辺構造が同じでも**マークの位置関係**が違えば分割できる。

- **RTP（Round-Trip Pair）**：`[1] a [0] c`  
  - 中間で上書き `[0]` を挟む。**“マークの上書き効果”**で微差を強調。  
  - 目的：コピー間で**更新衝突の経路**が異なる場合に効く。

> 実験語は**接尾語**として用いる。`Out(s,e)` の末端（到達室）や途中の観測差が DT 枝に反映され、**葉が分裂**する。

### 4.2 追加の設計ガイド

- テンプレは常に**最短版を優先**（`[k]` は 0コストなので遠慮なく挿入）。  
- **Σ 歩数の上限（6n）**に合わせ、`e` の Σ 部分は極力 1〜2 ステップで収める。  
- DT 矛盾が起きた**最短反例**を必ず採用（分類木の深さを増やしすぎない）。

---

## 5. プラン生成とパッキング（/explore 最適化の骨子）

- **問い合わせ単位**：`(s,e)` を**1プラン**として送るのが最小単位。  
  - 実際には複数 `(s,e)` を**一括**で `/explore`。呼出し回数を抑える。

- **コスト見積もり**：  
  - ドア歩数＝`|s| + |e|_Σ`（`|e|_Σ` は `e` の Σ 部分だけを数える）。  
  - `[k]` は 0。

- **パッキング**：  
  1 回の `/explore` で送る全プランの**合計**ではなく、**各プランごと**に `≤ 6·|V_known|` を守る。  
  超過しそうな `(s,e)` は、安全に**分割**（例えば `s` の prefix を別プランで先行取得）。

- **キャッシュ**：  
  同一 `s` の**prefix**観測は再利用可能。`E` の更新で必要な観測を**差分抽出**して最小化。

---

## 6. 提出グラフへの変換（扉↔扉の 1:1 対応）

- 仮説機（Σ′-最小）から、各状態 `q` と扉 `a` に対し `q' = δ(q,a)` を取得。  
- **相手側ポート** `b` は「`δ(q',b) = q` となる唯一の `b`」として**決まる**（表引きのみ）。  
- 多重辺・自己ループ：未ペアのポートを**貪欲**に 1:1 でマッチング。  
- **整合チェック**：  
  - 全 `(room, door)` が**ちょうど 1 回**現れ、相互参照が一致。  
  - 破綻があれば、その差分を**反例実験語**として `E` に注入し、DT を 1 反復。

---

## 7. 正しさ（スケッチ）

- DT は `Out(s,e)` の観測等価で最小化されるため、**Σ′（= マーキング込み）**で区別可能な状態は**必ず分離**される。  
- Addendum 問題のクローンは、`[k]` を含む `E` によって**観測差を誘発**でき、**同値条件（マーキング入りプラン）**に従う**最小機械**が得られる。  
- 無向ペアリングは `δ` の双方向性から**一意**に回収できる（追加探索不要）。

---

## 8. クエリ規模（目安）

- DT による学習：状態数 `n` に対して **O(n log n)** 規模（経験則）。  
- 実験語は**短いもの中心**で差別力を確保。  
- `/explore` 呼出しは**二桁以内**に圧縮可能（完全バッチング前提）。

---

## 9. 段階導入ロードマップ（TODO / DoD 付き）

> 各ステップは**単体で正しい解法**。以降のステップは効率化・堅牢化。

### S1（Lightning 完全対応：Σ の DT）
- 実装：アクセス語 BFS、DT（閉包/整合性）、最短接尾語生成（Σ のみ）。  
- 提出：`δ` → 無向ペアリング → JSON。  
- DoD：Lightning 問題で正解（マーキング不要系）。

### S2（Addendum 正解器：Σ′ の DT）
- 実装：`E` に `[k]` を含む**短いテンプレ**（LC/MR/2HR/RTP）を導入。  
- DT の反例は常に**最短**で採用。  
- DoD：クローンを DT だけで分割し、Addendum 問題も正解。

### S3（提出器の完成）
- 実装：無向ペアリングの**表引き**、自己ループ・多重辺の 1:1 割当、整合チェック。  
- DoD：代表問題セットで `correct:true` を再現。

### S4（クエリ最適化）
- 実装：**完全バッチング**、観測キャッシュ、`E` の最短化・重複抑制。  
- DoD：同問題で `/explore` 呼出し数を有意に削減。

### S5（6n 制約パッキング）
- 実装：各プランの Σ 歩数見積もり、**安全分割**と貪欲パッキング。  
- DoD：すべてのプランが制約内。正答維持。

### S6（検査と頑健化）
- 実装：**軽量チェック列**（W/H 風）で仮説機 vs 実機の差分検出。  
- 差分は**反例**として `E` に注入し再収束。  
- DoD：提出前チェックの恒常合格。

### S7（上位スコア向けオプション）
- 優先 prefix のハブ化、テンプレ適用順のヒューリスティクス、確率的初期 `E`。  
- DoD：ベンチで queryCount をさらに削減。

---

## 10. リスクと回避策

- **`6n` 超過**：プラン生成時に Σ 歩数を**静的見積り**し、超過前に分割。  
- **クローン未分離**：`E` に `[k]` を含むテンプレを**必ず**投入し、DT 矛盾からの最短反例を厳守。  
- **多重辺の衝突**：提出直前の**相互参照検査**で検出→反例注入→再学習。  
- **観測の重複**：キャッシュ徹底。prefix/suffix 再利用ロジックを設ける。  
- **観測列の解釈違い**：抽象レイヤで `end_label(plan)` と `trace_signature(plan)` を統一。

---

## 11. 実装仕様（抜粋・非コード）

- **観測正規化レイヤ**  
  - `end_label(plan)`：観測列の**最終要素**を返す。  
  - `trace_signature(plan)`：DT 比較用の短い署名（ハッシュや短整数列）。

- **DT 更新ループ**  
  - 入力：未評価の `(s,e)` 集合。  
  - 処理：バッチ `/explore` → 観測取り込み → **閉包/整合性**チェック → **反例 e*** 追加。  
  - 出力：新しい仮説機（Σ′-最小）。

- **プラン・パッカー**  
  - 各 `(s,e)` の Σ 歩数を見積もり、`≤ 6·|V_known|` を**強制**。  
  - `[k]` は自由挿入可能（0 コスト）。

- **提出生成**  
  - `rooms`：各状態の `end_label(access)`。  
  - `connections`：`(room,door)` ↔ `(room',door')` を 1 回ずつ。  
  - 一括**整合検査**（重複・欠落・逆参照）。

---

## 12. 付録：用語・記号

- `Σ`：扉 0..5 のアルファベット。  
- `Σ′`：`Σ ∪ {[0],[1],[2],[3]}`。  
- アクセス語 `s`：開始からの移動列（Σ のみ）。  
- 実験語 `e`：短い接尾語（`[k]` と Σ の組み合わせ）。  
- 観測 `Out(s,e)`：プラン `s·e` の観測列（末端ラベルを主に使用）。  
- DT：Discrimination Tree（分類木）。  
- 閉包/整合性：DT の学習収束条件。  
- LC/MR/2HR/RTP：本書のマーキング実験語テンプレ。

---

### 一言での設計指針
1. **DT で“Σ′-最小”に到達**する（クローンは `[k]` 接尾語で割る）。  
2. その `δ` から**無向ペアリングを機械的に回収**する。  
3. すべてのクエリは**短い実験語 × 完全バッチング**で送る。

この順序が、正しさと queryCount の最良バランスを与える。
